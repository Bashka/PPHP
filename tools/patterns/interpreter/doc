h1: Терминология
- Интерпретация объекта - преобразование объекта в данные иного типа;
- Восстановление объекта - восстановление состояния объекта на основании объекта-основания;
- Объект-основание - объект (или данные другого типа), состояние которого используется в качестве основы для постоения другого объекта;
- Строка-основание - строка, являющаяся объектом-основанием;
- Лексема - минимальный элемент строки;
- Шаблон верификации - регулярное выражение, которому должна соответствовать строка-основание, чтобы из нее возможно было восстановить объект. Данное регулярное выражение так же разбивает строку-основание на лексемы;
- Именованная лексема - компонент регулярного выражения, который может быть встроен в шаблон верификации для поиска конкретной лексемы.

h1: Виды преобразований и их семантика
Часто требуется преобразовать данные одного типа в другой. Отсюда можно выделить следующие виды преобразований:
- Преобразование объекта в элементарные типы данных (интерпретация);
- Восстановление состояния объекта из элементарных типов данных (восстановление) или другого объекта (метаморфоза).
Данный пакет служит для определения семантики классов, реализующих любой из указанных видов преобразований, а так же включает некоторую реализацию этих видов:
- Metamorphosis - интерфейс, используемый теми классами, которые могут быть инстанциированы из объектов других классов;
- Interpreter - интерфейс, используемый теми классами, которые могут быть преобразованы в данные типа string;
- Restorable - интерфейс, используемый теми классами, объекты которых могут быть восстановлены из данных типа string.
- TRestorable - частичная реализация интерфейса Restorable.

h2: Метоморфоза
Процесс создания объекта одного класса на основании объекта другого класса называется метоморфозом. Классы, позволяющие выполнять данное восстановление должны реализовать интерфейс Metamorphosis и в частности метод metamorphose, который должен выполнять инстанциацию объекта.
Метод metamorphose является статичным, так как служит для инстанциации объекта. Этот метод принимает в качестве первого аргумента объект-основание, а в качестве второго может принимать дополнительные входные данные, используемые для восстановления.
В качестве примера реализуем простой механизм метаморфоза. В качестве объекта-основания используем объект следующего класса:
code: php 300
class File{
  private $name; // Имя файла

  private $address; // Адрес файла

  private $location; // Каталог, хранящий файл

  public function getName(){
    return $this->name;
  }

  public function getAddress(){
    return $this->address;
  }

  public function getLocation(){
    return $this->location;
  }

  public function __construct($location, $name){
    $this->name = $name;
    $this->location = $location;
    $this->address = $location . '\\' . $name;
  }
}
code: end
Данный класс представляет файл в файловой системе. Этот класс очень упрощен в целях демонстрации и включает только такие свойства как имя и адрес файла.
Предположим нам необходимо создать на его основе объект класса Ссылка, который будет представлять символическую ссылку на файл. Для этого достаточно реализовать интерфейс Metamorphosis:
code: php 200
class Link implements Metamorphosis{
  private $addressFile; // Имя и адрес целевого файла

  private $location; // Каталог, хранящий ссылку

  private $name; // Имя ссылки

  public static function metamorphose($object, $driver = null){
    return new self('LinkTo_'.$object->getName(), $object->getLocation(), $object->getAddress());
  }

  public function __construct($name, $location, $addressFile){
    $this->addressFile = $addressFile;
    $this->location = $location;
    $this->name = $name;
  }
}
code: end
Как видно из примера, объекты класса Link могут быть созданы (восстановлены) на основании объектов класса File, при этом имя ссылки будет состоять из префикса LinkTo_ и имени файла, а их родительский каталог будет соответствовать родительскому каталогу целевого файла.

h2: Интерпретация
Процесс преобразования объекта в данные строкового типа называется интерпретацией. Классы, позволяющие выполнять данное преобразование должны реализовать интерфейс Interpreter и в частности метод interpretation, который должен выполнять преобразование объекта и возвращать строку, созданную на его основании.
Метод interpretation может принимать качестве первого аргумента дополнительные данные, которые могут быть использованы для формирования целевой строки.
Метод interpretation очень напоминает один из стандартных методов языка PHP - __toString - разница лишь в том, что он является частью маркировочного интерфейса Interpreter, который свидетельствует о том, что объект может быть преобразован в строку.
В качестве примера добавим классу из предыдущей главы File возможность преобразования в строку, содержащую расположение и имя файла:
code: php 100
class File implements Interpreter{
  ...

  public function interpretation($driver = null){
    return $this->getLocation().' '.$this->getName();
  }
}
code: end
Обратите внимание на формат создаваемой методом interpretation строки. Она включает как имя, так и расположение файла, при чем оба этих значения разделены символом пробела. Это сделано специально для того, чтобы можно было легко восстановить исходный объект из полученной строки (в полном адресе файла не могут быть использованы пробелы, потому ошибки быть не может). Это еще одна особенность интерфейса Interpreter - классы его реализующие должны интерпретироваться в строку так, чтобы из нее можно было легко создать другой объект, в отличии от метода __toString.

h2: Восстановление
Процесс преобразования данных строкового типа в объект называется восстановлением. Классы, позволяющие выполнять данное восстановление должны реализовать интерфейс Restorable и в частности методы isReestablish и  reestablish, которые должны проверять возможность восстановления и выполнять его соответственно.
Метод isReestablish принимает в качестве первого аргумента строку-основание и может принимать качестве второго аргумента дополнительные данные, которые могут быть использованы для верификации.
Метод reestablish так же принимает в качестве первого аргумента строку-основание и может принимать качестве второго аргумента дополнительные данные, которые могут быть использованы для восстановления.
Для того, чтобы наш предыдущий пример был закончен, добавим классу File возможность восстановления его объектов из строки, возвращаемой методом interpretation, для этого просто реализуем интерфейс Restorable:
code: php 160
class File implements Interpreter, Restorable{
  ...

  public static function isReestablish($string, $driver = null){
    return preg_match('/^(\/[A-Za-z_]+)+ [A-Za-z_]+$/u', $string, $matches);
  }

  public static function reestablish($string, $driver = null){
    $tokens = explode(' ', $string);
    return new self($tokens[0], $tokens[1]);
  }
}
code: end
Метод isReestablish в данном примере позволяет восстанавливать объекты из адресов, имена каталогов и файла в которых не содержат ничего, кроме латинских букв и символа _. Данное ограничение не является частью интерфейса, а сделано для упрощения примера.
Как видно, теперь объекты класса File могут создаваться на основании строк, возвращаемых методом interpretation объектов того же класса. Это может использоваться в частности для сохранения объектов в файловых хранилищах и последующего их восстановления.

h1: Частичная реализация
Интерфейс Restorable частично реализует trait TRestorable, которые определяет одну из возможных техник восстановления объекта на основании строки - поиск и обработка лексем. Данная техника определяет следующий алгоритм восстановления объекта из строки:
1. Поиск лексем - разделение строки-основания на части;
2. Интерпретация лексем - определение семантики полученных частей;
3. Преобразование лексем - изменение полученных частей (не обязательно);
4. Восстановление объекта - создание объекта на основании полученных частей.
Основой в данной техники является лексема - минимальная, логически значимая часть строки. TRestorable определяет общие механизмы поиска и обработки лексем, но не реализует логику преобразования этих лексем (п. 3) и восстановления из них объекта (п. 4), за это должен отвечать конкретный класс.
Для поиска лексем используется массив шаблонов регулярных выражений (шаблоны верификации), который должен возвращать метод getMasks данного trait. Часто в разных шаблонах верификации используются одни и те же лексемы, потому можно выделить их в отдельнй ассоциативный массив, возвращаемый методом getPatterns, и использовать при формировании массива шаблонов верификации.
Поиск и интерпретацию лексем выполняет метод searchMask, который возвращает массив найденых лексем или false, если ни один шаблон верификации не подходит для восстановления объекта.
Метод searchMask используется в методе isReestablish для определения возможности восстановления объекта из строки.
Метод searchMask так же используется в методе reestablish, который переопределяет конкретный класс. Данный метод предоставляет лексемы для восстановления.
Процесс восстановления объекта из строки-основания с помощью TRestorable представлен на следующей схеме:
img: sequenceRestorable.png
Как видно конкретный класс использует TRestorable для поиска лексем, а тот в свою очерень использует методы getMasks и getPatterns, переопределенные в конкретном классе. Ответственность за восстановление объекта из лексем остается за конкретным классом.
В качестве примера реализуем класс File из предыдущего примера с использованием TRestorable. Так же воспользуемся абстрактным классом RestorableAdapter, который реализует интерфейс Restorable с использованием TRestorable:
code: php 200
class File extends RestorableAdapter implements Interpreter{
  ...

  public static function getMasks($driver = null){
    return ['((\/'.self::getPatterns()['fileName'].')+) ('.self::getPatterns()['fileName'].')']; // Шаблон верификации.
  }

  public static function getPatterns($driver = null){
    return ['fileName' => '[A-Za-z_]+']; // Именованная лексема, используемая в шаблоне верификации.
  }

  public static function reestablish($string, $driver = null){
    $tokens = parent::reestablish($string); // Вызов переопределенного метода в родительском классе для поиска лексем.
    return new self($tokens[1], $tokens[3]); // Формирование объекта из лексем.
  }
}
code: end
Обратите внимание что метод getPatterns возвращает именованный массив частей регулярного выражения (именованные лексемы). Эти поисковые компоненты используются в шаблоне верификации метода getMasks, что предотвращает дублирование. Другими словами если в будущем будет необходимо изменить шаблон поиска имени файла или каталога в шаблоне верификации, достаточно изменить именнованную лексему fileName в методе getPatterns.
Метод getMasks используется автоматически в методе reestablish родительского класса, что позволяет выделить искомые лексемы в соответствии с требованиями шаблона верификации. Стоит так же отметить, что вызов конструктора и передача ему лексем остается за методом reestablish дочернего класса.
Проверим как будет работать данный класс:
code: php 60
$f = File::reestablish('/dirA/dirB/dirC file');
echo $f->getLocation(); // /dirA/dirB/dirC
echo $f->getName(); // file
code: end