h1: Терминология
- Состояние объекта - совокупность значений всех свойств объекта;
- Идентификация состояния объекта - определения состояния объекта, относящегося к данному объекту;
- Объектный идентификатор - целочисленное значение, однозначно идентифицирующее состояние объекта;
- Proxy - объект, не имеющий состояния, но имеющий объектный идентификатор. Такого рода объекты обычно используются как объектные ссылки на свое состояние.

h1: Идентификация объектов
Когда необходимо отделить состояние объекта от самого объекта, на пример для записи этого состояния в файл с целью последующего восстановления объекта из него, необходимо определить некоторое значение или совокупность значений, с помощью которого можно однозначно идентифицировать состояние.
Для примера создадим класс, объекты которого могут быть сохранены в файл и восстановлены из него:
code: php 70
class People{
  private $name;
  private $phone;
}
code: end
Если получить состояние объекта (на пример в виде строки), то его можно сохранить в файл и в последующем прочитать из него с целью восстановления объекта.
Предположим мы создали несколько объектов класса People и сохранили их состояния в файл в следующем виде:
Ivan 12345
Pavel 23456
Boris 34567
Для поиска состояния объекта в файле достаточно разбить его на строки и использовать имя как средство идентификации, но это может привести к коллизии (неопределенности при выборе состояния), когда два объекта класса People имеют одинаковое значение свойства name.
Решить эту проблему можно добавив еще несколько свойств в класс People:
code: php 80
class People{
  private $name;
  private $firstName;
  private $phone;
}
code: end
Теперь найти состояние в файле можно не только по его имени, а по совокупности значений свойств name (имя) и firstName (фамилия), но может ли это защитить от коллизии? К сожалению нет, ведь у двух человек может быть одинаковое имя и фамилия.
Проблема коллизии может быть решена при использовании дополнительного свойства класса - идентификатора объекта (OID). Данное свойство хранит уникальное значение, с помощью которого можно однозначно идентифицировать состояние объекта:
code: php 80
class People{
  private $OID;
  private $name;
  private $phone;
}
code: end
Теперь файл состояний экземпляров класса People будет выглядить так:
1 Ivan 12345
2 Pavel 23456
3 Boris 34567
Очевидно, что если значение свойства OID не повторяется, то с помощью него можно однозначно идентифицировать состояние объекта.

h1: Идентификация и наследование
Как должен выглядеть механизм идентификации объекта в дочернем классе? В качестве примера создадим класс Student, который будет дочерним по отношению к классу People:
code: php 60
class Student extends People{
  private $course;
}
code: end
Объекты класса People должны иметь идентификаторы, отличные от объектов класса Student, это необходимо для идентификации самих объектов, иначе мы не сможем определить к какому классу относится то или иное состояние, но как лучше хранить состояния экземпляра класса Student, если его свойства частично относятся к классу People?
Так как объект Student для своего существования должен быть связан с объектом класса People, то можно использовать одно значение идентификатора для двух частей этого объекта.
Состояние экземпляров класса Student могут быть сохранены в файлв в следующем виде:
1 2
2 3
3 1
То есть Ivan сейчас на 2 курсе, Pavel на 3, а Boris на 1. Теперь для восстановления объекта класса Student нам нужно с помощью идентификатора найти состояние People и состояние Student, а затем объединить их.
Схематически такая идентификация может выглядеть так:
img: relation.png
Файл Peoples.db хранит часть состояния объекта (которая относится к классу People), а файл Student.db хранит другую его часть (относящуюся к классу Student), при этом можно легко восстановить полное состояние объекта, так как обе записи имеют одинаковый идентификатор. При этом если создать объект класса People, то он будет иметь уже другой идентификатор.

h1: Идентификация объектов не связанных классов
Для идентификации объектов используется два различных подхода, различающиеся составом идентификатора:
- Идентификация на уровне класса - в этом подходе для идентификации объекта используется связка - идентификатор + имя класса. При этом объекты разных классов могут иметь одинаковые идентификаторы. Данный подход требует больше памяти для хранения идентификатора, размер идентификатора не строго фиксирован (так как имя класса может быть любым), а так же данный подход сложно применять для идентификации дочерних объектов (описание в предыдущей главе);
- Идентификация на уровне всей системы - в этом подходе для идентификации объекта используется уникальный для любого класса идентификатор. При этом объекты разных классов не могут иметь одинаковые идентификаторы. Данный подход требует от идентификатора быть достаточно неповторимым, чтобы покрыть все объекты системы.

h1: Проблемы переполнения идентификатора и генератор
Выбор типа идентификатора очень важен, так как при использовании целочисленных идентификаторов может наступить момент, когда система не сможет хранить идентификатор достаточно большого размера в памяти.
Обычно за создание идентификатора отвечает не сам объект, а сторонняя служба идентификации - генератор идентификаторов объектов. Эта служба должна по запросу возвращать уникальный идентификатор.

h1: Proxy и Phantom
Как восстановить объект (восстановить его состояние), если известен его идентификатор? Достаточно получить его состояние с помощью идентификатора и установить его объекту. Часто объекты с невосстановленным состоянием представляются в виде объектов без состояния, но с установленным значением идентификатора. Такие объекты представляют собой ссылку на свое состояние и называются Proxy.
Противоположностью proxy объекта является phantom - объект с установленным состоянием, но без установленного значения идентификатора. После завершения работы программы состояния таких объектов удаляются и их невозможно восстановить.

h1: Реализация идентифицируемых объектов
Данный пакет не определяет подход к идентификации объектов, он лишь определяет семантику идентифицируемых классов и реализует ее.
Любой класс, состояние экземпляров которого могут быть идентифицированы с помощью объектного идентификатора, должны реализовать интерфейс OID данного пакета. Интерфейс включает методы для идентификации объекта, получения текущего идентификатора, определения Phantom объектов и создания Proxy объектов.
Классической реализацией интерфейса OID является TOID. Данный trait реализует всю семантику интерфейса используя защищенное свойство OID. В качестве идентификатора объекта данный trait использует целочисленный идентификатор типа integer.
Для примера создадим идентифицируемый класс People:
code: php 100
class People implements OID{
use TOID;
  private $name;
  private $phone;

  ... // getters методы класса
}
code: end
Теперь продемонстрируем процесс идентификации объектов этого класса:
code: php 190
$p = new People;
$p->setName('Ivan');
$p->setPhone('12345');
// Объект p пока Phantom, так как не идентифицирован.
echo $p->isOID(); // false - так как объект еще не идентифицирован.
$p->setOID(1); // Идентификация объекта.
// Теперь объект p идентифицирован. Его состояние может быть сохранено.
echo $p->isOID(); // true - так как объект уже идентифицирован.
$pp = People::getProxy(1);
// Объект pp является Proxy, так как не имеет состояния. По сути, он является ссылкой на состояние объекта p.
echo $pp->isOID(); // true - не смотря на то, что объект не имеет состояния, он идентифицирован.
echo $pp->getOID(); // 1 - текущий идентификатор объекта.
code: end
Как видно, объекты класса People могут ссылаться на состояния других объектов, если они имеют одинаковый идентификатор.

h1: Ограничения реализации
Так как Proxy объекты не имеют состояния, то метод getProxy не ожидает от конструктора класса параметров для идентификации объекта, это означает что классы, реализующие интерфейс через TOID, не должны определять конструкторы с обязательными аргументами, это касается так же и их дочерних классов.

h1: Семантика генератора
Данный пакет так же содержит интерфейс OIDGenerator, который реализуется теми классами, которые служат для генерации уникальных идентификаторов объектов.