h1: Терминология
- Фабрика - класс, ответственный за создание сложных объектов;
- Фабрика объектной SQL инструкции - фабрика, ответственная за создание одной из объектных SQL инструкций (Select, Update, Insert или Delete).

h1: Польза от использования фабрики
Процесс создания объектной SQL инструкции достаточно сложен из за большого числа компонентов и сложной структуры инструкций. Для решения этой проблемы может быть использован данный пакет, включающий несколько фабрик объектных SQL инструкций, таких как:
- Select - фабрика служит для создания объектной SQL инструкции Select;
- Update - фабрика служит для создания объектной SQL инструкции Update;
- Insert - фабрика служит для создания объектной SQL инструкции Insert;
- Delete - фабрика служит для создания объектной SQL инструкции Delete;
- Where - фабрика служит для создания объектного SQL компонента Where.
Все эти фабрики упрощают процесс конструирования объектных SQL инструкций путем использования упрощенного, объектного интерфейса и "цепных методов".

h1: Select
Фабрика Select позволяет создавать объектную SQL инструкцию Select со всеми допустимыми для этой инструкции компонентами.
Приведем пример создания простой объектной SQL инструкции Select с использованием фабрики:
code: php 40
echo $select->interpretation('mysql); // SELECT * FROM `people`
$select = Select::getInstance()->fields()->tables(['people'])->get(); // Результатом является объект класса PPHP\tools\patterns\database\query\Select
code: end
Как видно, для создания объектной SQL инструкции используется объект класса Select, который может быть получен через вызов метода getInstance (см. PPHP\tools\patterns\singleton), как и все остальные фабрики. Данный объект включает множество методов, вызов которых конструируют результирующую инструкцию определенным образом. Обратите внимание на способ вызова методов объекта, так как практически все методы возвращают ссылку на фабрику, возможен удобный "цепной вызов методов".
Для возврата из фабрики полученой в результате ее работы инструкции, используется метод get.
Приведем пример создания более сложной объектно SQL инструкции Select с использованием фабрики:
code: php 40
$select = Select::getInstance()->fields(['OID', 'people.name'])->tables(['people'])->orderBy(['name'])->where('OID', '>', '10')->select->get();
echo $select->interpretation('mysql); // SELECT `OID`,people.name FROM `people` ORDER BY `name` ASC WHERE (`OID` > "10")
code: end
Интерфейс взаимодействия с фабрикой несколько изменяется после вызова метода where, который определяет логическое выражение инструкции, это связано с особенностью реализации фабрики Where и будет рассмотрено далее.

h1: Update
Фабрика Update позволяет создавать объектную SQL инструкцию Update со всеми допустимыми для этой инструкции компонентами.
Приведем пример создания объектной SQL инструкции Update с использованием фабрики:
code: php 60
$update = Update::getInstance()->table('people')->data(['name' => 'nikolay'])->where('OID', '=', '1')->update->get(); // Результатом является объект класса PPHP\tools\patterns\database\query\Update
echo $update->interpretation('mysql); // UPDATE `people` SET `name` = "nikolay" WHERE (`OID` = "1")
code: end

h1: Insert
Фабрика Insert позволяет создавать объектную SQL инструкцию Insert со всеми допустимыми для этой инструкции компонентами, кроме возможности определения вложенного Select запроса.
Приведем пример создания объектной SQL инструкции Insert с использованием фабрики:
code: php 60
$insert = Insert::getInstance()->table('people')->data(['phone' => '00001', 'name' => 'nikolay'])->get(); // Результатом является объект класса PPHP\tools\patterns\database\query\Insert
echo insert->interpretation('mysql); // INSERT INTO `people` (`phone`, `name`) VALUES ("00001", "nikolay")
code: end

h1: Delete
Фабрика Delete позволяет создавать объектную SQL инструкцию Delete со всеми допустимыми для этой инструкции компонентами.
Приведем пример создания объектной SQL инструкции Delete с использованием фабрики:
code: php 60
$delete = Delete::getInstance()->table('people')->where('OID', '<', '10')->delete->get(); // Результатом является объект класса PPHP\tools\patterns\database\query\Delete
echo $delete->interpretation('mysql); // DELETE FROM `people` WHERE (`OID` < "10")
code: end

h1: Where
Фабрика Where отличается от рассмотренных ранее фабрик тем, что позволяет создавать объектный SQL компонент, а не инструкцию. Это связано с тем, что компонент Where достаточно сложна, иерархическая конструкция с вложенными выражениями и приоритетом операций.
Те фабрики (Select, Update, Delete), которые имеют метод where, конструируют инструкцию с помощью фабрики Where. Метод where возвращает объект фабрики Where, который отвечает за создание логического выражения для инструкции, при этом объект дополняется специальным свойством, имя которого соответствует имени инструкции (select, update, delete), которое ссылается на используемую фабрику для возврата к ней.
Рассмотрим пример использования Where фабрики:
code: php 40
$delete = Delete::getInstance()->table('people')->where('name', '=', 'ivan')->create('OID', '<', '5')->orC('OID', '>', '10')->last('AND')->delete->get(); // DELETE FROM `people` WHERE ((`name` = "ivan") AND ((`OID` < "5") OR (`OID` > "10")))
code: end
На схеме ниже изображен процесс работы фабрик Delete и Where:
img: whereBuilder.png
Как можно заметить, сначало используется фабрика Delete, но после вызова метода where, возвращается фабрика Where, которая используется для формирования сложного логического выражения. Свойство delete этой фабрики ссылается на используемую ранее фабрику Delete, что позволяет вернуться к этой фабрике, а метод get объединяет результат работы фабрик Delete и Where в одну инструкцию.
Фабрика where позволяет формировать логическое выражение с помощью методов andC и orC, которые добавляют справа к текущему логическому выражению логическую операцию с оператором И или ИЛИ соответственно. Данные методы позволяет создавать логические выражения, в которых приоритет снижается по мере продвижения к концу этого выражения. Приведм пример:
code: php 40
echo Where::getInstace()->create('OID', '>', '0')->orC('OID', '<', '10')->andC('name', '=', 'ivan')->last()->interpretation('mysql'); // WHERE ((`OID` > "0") OR (`OID` < "10")) AND (`name` = "ivan");
code: end
Очевидно, что этот механизм не позволяет определять порядок выполнения логической инструкции. На пример нельзя создать выражение вида: ((...) OR (...)) AND ((...) OR (...)) - с использованием только методов andC и orC. Но это возможно благодаря методам create и last.
Метод create создает вложенное логическое выражение, которое формируется так же, как и первое выражене в фабрике, но с той лишь разницей, что до вызова метода last оно не соединено с логическим выражением. Это новое логическое выражение помещается в стек и соединяется с предыдущим тогда, когда вызывается метод last с указанием логического оператора, объединяющего эти два выражения. Рассмотрим пример:
code: php 40
echo Where::getInstace()->create('OID', '>', '0')->orC('OID', '<', '10')->create('name', '=', 'ivan')->orC('name', '=', 'petr')->last('AND')->last()->interpretation('mysql'); // WHERE ((`OID` > "0") OR (`OID` < "10")) AND ((`name` = "ivan") OR (`name` = "petr"));
code: end
Следует так же обратить внимание на завершающий вызов метода last без параметров, он возвращает сформированое фабрикой логическое выражение (подобно методу get у фабрик инструкций). Данный метод можно не вызывать при использовании фабрик Select, Update, Insert и Delete, так как он автоматически вызывается при вызове у этих фабрик метода get.