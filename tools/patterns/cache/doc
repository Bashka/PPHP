h1: Терминология
- Пользователь - программный компонент, обращающийся к ресурсу с целью получения от него данных;
- Ресурс - программный компонент, предоставляющий требуемые пользователю данные;
- Данные - информация любого доступного (для языка PHP) типа, однозначно идентифицируемая по средствам строки-идентификатора;
- Идентификатор данных - строка, однозначно идентифицирующая данные;
- Кэш - программный компонент, обеспечивающий хранение часто используемых данных на время исполнения скрипта для увеличения скорости доступа к ним;
- Ограниченный кэш - кэш, число хранимых данных в котором ограничено некоторой конечно велечиной (объем кэша). При добавлении новых данных в такой кэш, устаревшие данные удаляются из него по правилу "очереди";
- Устаревшие данные - данные, добавленные в кэш первыми в момент добавления новых данных в заполненный, ограниченный кэш;
- Неограниченный кэш - кэш, число хранимых данных в котором не ограничено;
- Плотность кэша - число хранящихся в кэше данных;
- Отчистка кэша - процесс удаление данных, хранящихся в кэше.

h1: Польза простого кэша
Механизм кэширования часто применяется для повышения скорости доступа к данным за счет хранения их в кэше. Простой кэш, реализованный в данном пакете, позволяет сохранять данные только на период исполнения скрипта, после чего данные удаляются. Это можно использовать для доступа к повторно запрашиваемой информации, на пример строкам файла или сложным объектам.
Для упрощения доступа к данным простой кэш, реализованный в данном пакете, использует текстовый идентификатор и целевой ресурс кэша. В качестве идентификатора может использоваться любая строка, однозначно идентифицирующая данные, на пример номер стоки в файле, или имя объекта, или идентификатор записи в базе данных. В случае, если полученные данные необходимо еще и дополнить информацией из кэша, на пример ссылками на объекты, примеряется дополнительный параметр. В качестве целевого ресурса кэша может быть использован любой объект или другой тип данных. Встречаются так же кэши-фабрики - это кэши, которые не используют целевой ресурс для запроса данных, а сами создают объекты в зависимости от идентификатора данных и кэшируют их.
Особенностью любого кэша является его объем, то есть количество данных, которые может хранить в себе кэш. В случае переполнения кэша, старые данные должны заменяться на новые. Это позволяет своевременно удалять устаревшие данные их кэша и исключить переполнение памяти ненужными данными. Реализованный в данном пакете простой кэш позволяет не только следить за своевременым удалением устаревших данных, но и динамически изменять природу их хранения, становять как неограниченным, так и не кэширующим.

h1: Способ реализации
В качестве примера создадим два кэша, первый для кэширования строк файла, второй для кэширования создаваемых объектов. Для этого необходимо конкретезировать класс Cache данного пакета и реализовать в дочернем классе метод getFromSource, который должен запрашивать данные из ресурса и возвращать их. Заметьте, что метод объявлен как protected, то есть вызов этого метода выполняется не программистом, а самим классом Cache, в частности его методом getData, который является "шаблонным".
Кэширование выполняется автоматически методом getData согласно следующей схеме:
img: sequence.png
Как видно при вызове метода getData кэш определяет, располагает ли он запрашиваемыми метода, и если да, то возвращает их пользователю, иначе обращается к методо getFromSource, который, в свою очередь, запрашивает данные у ресурса и возвращает их в кэш, после чего они кэшируются и возвращаются пользователю.

h2: Класический кэш
Первый класс должен кэшировать данные, предоставляемые следующим классом:
code: php 160
class File{
  /**
   * Метод считывает из файла и возвращает строку с указанным номером. Отсчет начинается от нуля.
   * @param integer $num Номер запрашиваемой строки.
   * @return string|null Запрошенная строка или null в случае, если указанной строки нет в файле.
   */
   public function readLine($num){
      ...
   }
}
code: end
Для реализации подходящего кэша достаточно реализовать метод getFromSource, который будет принимать в качестве идентификатор данных номер запрашиваемой строки, а дополнительный аргумент arguments использоваться не будет:
code: php 90
class FileCache extends Cache{
  protected function getFromSource($key, array $arguments = null){
    return $this->resource->readLine((integer) $key);
  }
}
code: end
Создается данный кэш путем передачи ему объекта класса File в конструктор при инстанциации:
code: php 20
$fc = new FileCache(20, new File('test.txt'));
code: end
Используется данный кэш путем вызова метода getData и передачей ему номера запрашиваемой строки. Метод возвращает запрашиваемую строку предварительно кэшируя ее. Теперь при повторном запросе этой строки данные будут возвращены из кэша:
code: php 40
$data = $fc->getData(0);
$data = $fc->getData(0); // Данные возвращаются из кэша.
code: end

h2: Кэш-фабрика и дополнение данных
Второй класс отличается тем, что не использует целевой ресурс для запроса данных, а самостоятельно создает данные при запросе. Предположим что необходимо создавать объекты следующих классов при запросе из кэша:
code: php 250
class OpenState{
  /**
   * @param object $context Контекст состояния.
   */
  public function __construct($context){
    // ...
  }
}

class CloseState{
  /**
   * @param object $context Контекст состояния.
   */
  public function __construct($context){
    // ...
  }
}
code: end