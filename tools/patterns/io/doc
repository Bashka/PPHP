h1: Терминология
- Ресурс - Источник или приемник данных;
- Поток - Абстракция, представляющая механизм записи данных в ресурс или чтения данных из него;
- Входной поток - поток, позволяющий получать данные из ресурса;
- Выходной поток - поток, позволяющий записывать данные в ресурс;
- Последовательный поток - поток, позволяющий считывать или записывать данные последовательно без возможности указания позиции текущего байта;
- Хаотичный (упорядоченный) поток - поток, позволяющий считыват или записывать данны не последовательно с возможностью указания позиции текущего байта;
- Указатель текущего байта - позиция байта данных в потоке, который будет считан следующим или в который будет произведена следующая запись;
- Закрытие потока - завершение манипуляций над потоком и освобождение ресурса.

h1: Поточный ввод/вывод
Потоки представляют собой абстракцию над механизмом записи и чтения данных. Потоки унифицируют интерфейс взаимодействия с различными ресурсами, предоставляющими данные или позволяющие передавать им их.
Классы, реализующие интерфейсы данного пакета представляют входные или выходные потоки для различных ресурсов системы, при этом они полиморфны (взаимозаменяемы), что упрощает процесс взаимодействия с различными ресурсами.
Потоки делятся на два типа:
- Входной поток (In stream) - представляет собой объект, который возвращает данные из ресурса по запросу пользователя;
- Выходной поток (Out stream) - представляет собой объект, который передает данные в ресурс от пользователя.

h1: Входной поток
Входные потоки используются для чтения данных из ресурса. Как правило эти потоки работают с данными побайтово.
Интерфейс Reader определяет семантику классов, представляющих входные потоки. Данный интерфейс включает один основной метод read, позволяющий получить один текущий байт из потока, и три вспомогательных ("сахорных") метода:
- readString - метод считывает указанное число байт из потока;
- readLine - метод считывает строку из потока;
- readAll - метод считывает все данные, доступные в потоке.
Так как вспомогательные методы (readString, readLine, readAll) обычно реализуются через основной метод read, путем определенных циклических и условных манипуляций над данными, в пакете присутствует частичная реализация данного интерфейса - абстрактный класс InStream, в котором реализованы все вспомогательные методы интерфейса.
В качестве примера реализуем файловый входной поток, который будет считывать данные из файла. Для этого используем реализацию InStream:
code: php 160
class FileReader extends InStream{
  public function read(){
    $result = fread($this->resource, 1);
    if($result === false){
      throw new io\IOException('Ошибка использования потока ввода.');
    }

    return $result;
  }
}
code: end
Обратите внимание на свойство resource. Оно определено в классе InStream и хранит ссылку на файловый ресурс, который связывается с потоком через конструктор, который так же реализован в InStream.
Так как метод read реализован строго согласно семантики интерфейса Reader, мы можем быть уверены, что все вспомогательные методы этого интерфейса так же правильно реализованы.
Вот как данный поток используется:
code: php 80
$fi = new FileReader(fopen('file', 'r'));
echo $fi->read(); // Считываем первый байт.
echo $fi->readString(5); // Считываем следующие 5 байт.
echo $fi->readLine(); // Считываем следующую строку.
echo $fi->readAll(); // Считываем оставшиеся в потоке данные.
code: end

h1: Выходной поток
Выходные потоки используются для записи данных в ресурс. Как правило эти потоки работают с данными побайтово.
Интерфейс Writer определяет семантику классов, представляющих выходные потоки. Данный интерфейс включает один основной метод write, позволяющий записывать пакет байт в поток.
По аналогии с классом InStream в пакете присутствует класс OutStream, представляющий реализацию выходного потока. В данном классе так же присутствует свойство resource, представляющее целевой ресурс потока, и реализован конструктор.
В качестве примера реализуем файловый выходной поток, который будет записывать данные в файл. Для этого используем реализацию OutStream:
code: php 160
class FileWriter extends OutStream{
  public function write($data){
    $result = fwrite($this->resource, $data);
    if($result === false){
      throw new io\IOException('Ошибка использования потока вывода.');
    }

    return $result;
  }
}
code: end
Вот как данный поток используется:
code: php 40
$fo = new FileWriter('file', 'w');
$fo->write('Hello world!'); // Запись пакета байт в файл.
code: end

h1: Закрытие потока
Некоторые потоки могут блокировать свои целевые ресурсы, или использовать слишком много памяти для работы, или информировать ресурс об окончании их использования. Как правило такого рода потоки можно закрыть, то есть выполнить некоторую операцию, освобождающую ресурс после завершения использования потока.
Потоки, которые необходимо закрывать после использования должны реализовывать интерфейс Closed, который включает единственный метод close, закрывающий поток.
Добавим возможность закрытия файлового потока вывода для класса из предыдущего примера. Для этого реализуем интерфейс Closed:
code: php 140
class FileWriter extends OutStream implements Closed{
  public function write($data){
    ...
  }

  public function close(){
    return fclose($this->resource);
  }
}
code: end
Теперь файловый выходной поток может быть закрыт с целью освобождения ресурса или (на пример) снятия с него блокировки:
code: php 60
$fo = new FileWriter('file', 'w');
... // Использование потока.
$fo->close();
code: end

h1: Поток со свободным доступом
Если вернуться к реализованному ранее классу FireReader, можно заметить, что данный поток не позволяет, на пример, пропустить какой то объем данных перед считыванием (начать читать данные не с первого байта). Такие потоки называются последовательными, то есть предоставляющими данные строго побайтно без возможности повторного считывания или пропуска байт.
Некоторые потоки, которые называются хаотичными, наоборот позволяют ссылаться на различные части данных для изменения порядка их чтения и записи. Такого рода потоки должны реализовать интерфейс SeekIO, который включает два метода:
- setPosition - устанавливает позицию байта (указатель текущего байта), с которого начнется считывание или запись;
- getPosition - определяет позицию указателя текущего байта.
Добавим возможность хаотичного доступа к классу FileReader:
code: php 300
class FileReader extends InStream implements SeekIO{
  public function read(){
    ...
  }

  public function setPosition($position){
    return (boolean) (fseek($this->resource, $position) + 1);
  }

  public function getPosition(){
    $result = ftell($this->resource);
    if($result === false){
      throw new io\IOException('Ошибка использования потока ввода.');
    }

    return $result;
  }
}
code: end
Теперь возможно читать данные из файла начиная с любой позиции:
code: php 60
$fi = new FileReader(fopen('file', 'r'));
echo $fi->setPosition(5);
echo $fi->readString(5); // Считываем байты между 5 и 10 позициями.
code: end